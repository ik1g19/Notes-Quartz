# Contents

- P1. Functional and Implementational Content %%[[Uni PDFs/Programming 3.pdf#page=1|P1]]%%
- P1. Functional Sum of Squares %%[[Uni PDFs/Programming 3.pdf#page=1|P1]]%%
- P2. Functional Quicksort %%[[Uni PDFs/Programming 3.pdf#page=2|P2]]%%
- P3. Features of Haskell %%[[Uni PDFs/Programming 3.pdf#page=3|P3]]%%
- P3. Getting Started with Haskell %%[[Uni PDFs/Programming 3.pdf#page=3|P3]]%%
- P6. Haskell Scripts %%[[Uni PDFs/Programming 3.pdf#page=6|P6]]%%
- P9. Basic Types %%[[Uni PDFs/Programming 3.pdf#page=9|P9]]%%
- P11. Bool %%[[Uni PDFs/Programming 3.pdf#page=11|P11]]%%
- P11. Char %%[[Uni PDFs/Programming 3.pdf#page=11|P11]]%%
- P12. String %%[[Uni PDFs/Programming 3.pdf#page=12|P12]]%%
- P12. Numbers %%[[Uni PDFs/Programming 3.pdf#page=12|P12]]%%
- P12. Types and Classes %%[[Uni PDFs/Programming 3.pdf#page=12|P12]]%%
- P12. Type Operators %%[[Uni PDFs/Programming 3.pdf#page=12|P12]]%%
- P13. Data Constructors %%[[Uni PDFs/Programming 3.pdf#page=13|P13]]%%
- P13. Lists %%[[Uni PDFs/Programming 3.pdf#page=13|P13]]%%
- P14. List Values %%[[Uni PDFs/Programming 3.pdf#page=14|P14]]%%
- P15. Tuples %%[[Uni PDFs/Programming 3.pdf#page=15|P15]]%%
- P15. Function Types %%[[Uni PDFs/Programming 3.pdf#page=15|P15]]%%
- P15. Curried Functions %%[[Uni PDFs/Programming 3.pdf#page=15|P15]]%%
- P17. Polymorphism and Classes %%[[Uni PDFs/Programming 3.pdf#page=17|P17]]%%
- P17. Class Constraints %%[[Uni PDFs/Programming 3.pdf#page=17|P17]]%%
- P17. Type Classes %%[[Uni PDFs/Programming 3.pdf#page=17|P17]]%%
- P18. Built in Type Classes %%[[Uni PDFs/Programming 3.pdf#page=18|P18]]%%
- P18. Eq Class %%[[Uni PDFs/Programming 3.pdf#page=18|P18]]%%
- P18. Ord Class %%[[Uni PDFs/Programming 3.pdf#page=18|P18]]%%
- P18. Show Class %%[[Uni PDFs/Programming 3.pdf#page=18|P18]]%%
- P19. Read Class %%[[Uni PDFs/Programming 3.pdf#page=19|P19]]%%
- P19. Number Class %%[[Uni PDFs/Programming 3.pdf#page=19|P19]]%%
- P19. Integral Class %%[[Uni PDFs/Programming 3.pdf#page=19|P19]]%%
- P19. Fractional Class %%[[Uni PDFs/Programming 3.pdf#page=19|P19]]%%
- P20. Defining Functions %%[[Uni PDFs/Programming 3.pdf#page=20|P20]]%%
- P20. Guarded Equations %%[[Uni PDFs/Programming 3.pdf#page=20|P20]]%%
- P20. Error Cases %%[[Uni PDFs/Programming 3.pdf#page=20|P20]]%%
- P21. Pattern Matching %%[[Uni PDFs/Programming 3.pdf#page=21|P21]]%%
- P22. Functions as Values %%[[Uni PDFs/Programming 3.pdf#page=22|P22]]%%
- P22. Lambda Expressions %%[[Uni PDFs/Programming 3.pdf#page=22|P22]]%%
- P23. Operator Sections %%[[Uni PDFs/Programming 3.pdf#page=23|P23]]%%
- P24. List Comprehension %%[[Uni PDFs/Programming 3.pdf#page=24|P24]]%%
- P26. Tail Recursion %%[[Uni PDFs/Programming 3.pdf#page=26|P26]]%%
- P27. Tail vs Non-Tail %%[[Uni PDFs/Programming 3.pdf#page=27|P27]]%%
- P27. Using Zip %%[[Uni PDFs/Programming 3.pdf#page=27|P27]]%%
- P28. Higher Order Functions %%[[Uni PDFs/Programming 3.pdf#page=28|P28]]%%
- P28. Map %%[[Uni PDFs/Programming 3.pdf#page=28|P28]]%%
- P28. Filter %%[[Uni PDFs/Programming 3.pdf#page=28|P28]]%%
- P29. $ %%[[Uni PDFs/Programming 3.pdf#page=29|P29]]%%
- P29. Function Composition %%[[Uni PDFs/Programming 3.pdf#page=29|P29]]%%
- P29. Folding %%[[Uni PDFs/Programming 3.pdf#page=29|P29]]%%
- P30. Declaring Types and Classes %%[[Uni PDFs/Programming 3.pdf#page=30|P30]]%%
- P30. Type Synonyms %%[[Uni PDFs/Programming 3.pdf#page=30|P30]]%%
- P31. Simple Constructors %%[[Uni PDFs/Programming 3.pdf#page=31|P31]]%%
- P32. Data %%[[Uni PDFs/Programming 3.pdf#page=32|P32]]%%
- P34. New Types %%[[Uni PDFs/Programming 3.pdf#page=34|P34]]%%
- P34. Recursive Types %%[[Uni PDFs/Programming 3.pdf#page=34|P34]]%%
- P35. Defining Classes %%[[Uni PDFs/Programming 3.pdf#page=35|P35]]%%
- P35. Declaring Instances %%[[Uni PDFs/Programming 3.pdf#page=35|P35]]%%
- P35. Deriving Instances %%[[Uni PDFs/Programming 3.pdf#page=35|P35]]%%
- P36. Abstract Syntax Trees %%[[Uni PDFs/Programming 3.pdf#page=36|P36]]%%
- P36. Concrete Syntax Tree %%[[Uni PDFs/Programming 3.pdf#page=36|P36]]%%
- P37. Programs as Abstract Syntax Trees %%[[Uni PDFs/Programming 3.pdf#page=37|P37]]%%
- P38. Trees in Haskell %%[[Uni PDFs/Programming 3.pdf#page=38|P38]]%%
- P38. Mapping Trees %%[[Uni PDFs/Programming 3.pdf#page=38|P38]]%%
- P38. Functors %%[[Uni PDFs/Programming 3.pdf#page=38|P38]]%%
- P39. Zippers %%[[Uni PDFs/Programming 3.pdf#page=39|P39]]%%
- P41. Graphs in Haskell %%[[Uni PDFs/Programming 3.pdf#page=41|P41]]%%
- P41. The Indexed Approach %%[[Uni PDFs/Programming 3.pdf#page=41|P41]]%%
- P42. Using Cyclic Dependencies %%[[Uni PDFs/Programming 3.pdf#page=42|P42]]%%
- P44. Inductive Graphs %%[[Uni PDFs/Programming 3.pdf#page=44|P44]]%%
- P45. Graph Decomposition %%[[Uni PDFs/Programming 3.pdf#page=45|P45]]%%
- P46. Using Stack and Cabal %%[[Uni PDFs/Programming 3.pdf#page=46|P46]]%%
- P48. Testing and QuickCheck %%[[Uni PDFs/Programming 3.pdf#page=48|P48]]%%
- P49. Equational Reasoning %%[[Uni PDFs/Programming 3.pdf#page=49|P49]]%%
- P50. Structural Induction %%[[Uni PDFs/Programming 3.pdf#page=50|P50]]%%
- P51. Evaluation Strategies %%[[Uni PDFs/Programming 3.pdf#page=51|P51]]%%
- P51. Reducible Expressions %%[[Uni PDFs/Programming 3.pdf#page=51|P51]]%%
- P52. Evaluation Strategy %%[[Uni PDFs/Programming 3.pdf#page=52|P52]]%%
- P53. Call by Value and Call by Name %%[[Uni PDFs/Programming 3.pdf#page=53|P53]]%%
- P55. Lazy Evaluation %%[[Uni PDFs/Programming 3.pdf#page=55|P55]]%%
- P56. Strict Application %%[[Uni PDFs/Programming 3.pdf#page=56|P56]]%%
- P56. Lambda Calculus %%[[Uni PDFs/Programming 3.pdf#page=56|P56]]%%
- P57. Free Variables and Closed Terms %%[[Uni PDFs/Programming 3.pdf#page=57|P57]]%%
- P57. Alpha Conversion and Alpha Equivalence %%[[Uni PDFs/Programming 3.pdf#page=57|P57]]%%
- P58. Beta Reduction %%[[Uni PDFs/Programming 3.pdf#page=58|P58]]%%
- P59. Implementing Beta Reduction %%[[Uni PDFs/Programming 3.pdf#page=59|P59]]%%
- P61. Making a Multi-Step Evaluator %%[[Uni PDFs/Programming 3.pdf#page=61|P61]]%%
- P62. Call by Value Evaluation %%[[Uni PDFs/Programming 3.pdf#page=62|P62]]%%
- P62. Environments %%[[Uni PDFs/Programming 3.pdf#page=62|P62]]%%
- P64. Continuations %%[[Uni PDFs/Programming 3.pdf#page=64|P64]]%%
- P64. Achieving Focus - Call by Value %%[[Uni PDFs/Programming 3.pdf#page=64|P64]]%%
- P65. Frames and Continuations %%[[Uni PDFs/Programming 3.pdf#page=65|P65]]%%
- P65. Machine Based Reductions %%[[Uni PDFs/Programming 3.pdf#page=65|P65]]%%
- P67. Closures %%[[Uni PDFs/Programming 3.pdf#page=67|P67]]%%
- P68. Rewriting CEK Machines %%[[Uni PDFs/Programming 3.pdf#page=68|P68]]%%
- P69. Input/Output in Haskell %%[[Uni PDFs/Programming 3.pdf#page=69|P69]]%%
- P69. Actions %%[[Uni PDFs/Programming 3.pdf#page=69|P69]]%%
- P70. Do %%[[Uni PDFs/Programming 3.pdf#page=70|P70]]%%
- P72. Random Actions %%[[Uni PDFs/Programming 3.pdf#page=72|P72]]%%
- P72. Monadic Parsing %%[[Uni PDFs/Programming 3.pdf#page=72|P72]]%%
- P76. Applications %%[[Uni PDFs/Programming 3.pdf#page=76|P76]]%%
- P76. Applicative Laws %%[[Uni PDFs/Programming 3.pdf#page=76|P76]]%%
- P77. Monads %%[[Uni PDFs/Programming 3.pdf#page=77|P77]]%%
- P78. Monad Laws %%[[Uni PDFs/Programming 3.pdf#page=78|P78]]%%
- P78. Monads: Error Handling %%[[Uni PDFs/Programming 3.pdf#page=78|P78]]%%
- P79. Monads: Chaining %%[[Uni PDFs/Programming 3.pdf#page=79|P79]]%%
- P80. Monads: Non-Determinism %%[[Uni PDFs/Programming 3.pdf#page=80|P80]]%%
- P81. Functional Programming in Java %%[[Uni PDFs/Programming 3.pdf#page=81|P81]]%%
- P82. Functional Interfaces %%[[Uni PDFs/Programming 3.pdf#page=82|P82]]%%
- P82. Lambda Syntax in Java %%[[Uni PDFs/Programming 3.pdf#page=82|P82]]%%
- P83. General Function Types %%[[Uni PDFs/Programming 3.pdf#page=83|P83]]%%
- P84. Closures in Java %%[[Uni PDFs/Programming 3.pdf#page=84|P84]]%%
- P84. Recursion %%[[Uni PDFs/Programming 3.pdf#page=84|P84]]%%
- P85. Method References %%[[Uni PDFs/Programming 3.pdf#page=85|P85]]%%

# Document

<iframe src="https://drive.google.com/file/d/12CXA26SLj8qBJ5nUGXI55bTMZchbu-Qu/preview" width="640" height="780" allow="autoplay"></iframe>